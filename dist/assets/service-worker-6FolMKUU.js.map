{"version":3,"file":"service-worker-6FolMKUU.js","sources":["../../public/service-worker.js"],"sourcesContent":["const CACHE_NAME = 'pwa-cache-v1';\r\nconst STATIC_CACHE_NAME = 'static-cache-v1';\r\nconst API_CACHE_NAME = 'api-cache-v1';\r\n\r\n// Add all your static assets here\r\nconst urlsToCache = [\r\n  '/',\r\n  '/index.html',\r\n  '/manifest.json',\r\n  '/favicon.ico',\r\n  '/static/js/main.js',\r\n  '/static/css/main.css',\r\n  // Add any other static assets your app needs\r\n];\r\n\r\n// Install event - Cache static assets\r\nself.addEventListener('install', (event) => {\r\n  event.waitUntil(\r\n    Promise.all([\r\n      // Cache static assets\r\n      caches.open(STATIC_CACHE_NAME).then((cache) => {\r\n        console.log('Caching static files');\r\n        return cache.addAll(urlsToCache);\r\n      }),\r\n      // Create API cache\r\n      caches.open(API_CACHE_NAME)\r\n    ])\r\n  );\r\n  // Force activation\r\n  self.skipWaiting();\r\n});\r\n\r\n// Activate event - Clean up old caches\r\nself.addEventListener('activate', (event) => {\r\n  event.waitUntil(\r\n    caches.keys().then((cacheNames) => {\r\n      return Promise.all(\r\n        cacheNames.map((cacheName) => {\r\n          if (cacheName !== STATIC_CACHE_NAME && cacheName !== API_CACHE_NAME) {\r\n            console.log('Deleting old cache:', cacheName);\r\n            return caches.delete(cacheName);\r\n          }\r\n        })\r\n      );\r\n    })\r\n  );\r\n  // Take control of all pages immediately\r\n  event.waitUntil(clients.claim());\r\n});\r\n\r\n// Helper function to determine if a request is API call\r\nconst isApiRequest = (request) => {\r\n  return request.url.includes('api.sampleapis.com');\r\n};\r\n\r\n// Fetch event - Handle both static and API requests\r\nself.addEventListener('fetch', (event) => {\r\n  event.respondWith(\r\n    (async () => {\r\n      try {\r\n        if (isApiRequest(event.request)) {\r\n          // Handle API requests\r\n          // Try cache first for API requests\r\n          const cachedResponse = await caches.match(event.request);\r\n          if (cachedResponse && !navigator.onLine) {\r\n            return cachedResponse;\r\n          }\r\n\r\n          try {\r\n            // If online, try network and update cache\r\n            const response = await fetch(event.request);\r\n            const responseToCache = response.clone();\r\n            \r\n            // Cache the new response\r\n            const cache = await caches.open(API_CACHE_NAME);\r\n            await cache.put(event.request, responseToCache);\r\n            \r\n            return response;\r\n          } catch (error) {\r\n            // If network fails, return cached version if available\r\n            const cachedResponse = await caches.match(event.request);\r\n            if (cachedResponse) {\r\n              return cachedResponse;\r\n            }\r\n            // If no cache, return offline response\r\n            return new Response(\r\n              JSON.stringify({ error: 'No cached data available and network request failed' }),\r\n              {\r\n                status: 503,\r\n                headers: { 'Content-Type': 'application/json' },\r\n              }\r\n            );\r\n          }\r\n        } else {\r\n          // Handle static assets - Cache First strategy\r\n          const cachedResponse = await caches.match(event.request);\r\n          if (cachedResponse) {\r\n            return cachedResponse;\r\n          }\r\n\r\n          // If not in cache, try network\r\n          try {\r\n            const response = await fetch(event.request);\r\n            // Cache the new static asset\r\n            const cache = await caches.open(STATIC_CACHE_NAME);\r\n            await cache.put(event.request, response.clone());\r\n            return response;\r\n          } catch (error) {\r\n            // For HTML requests when offline, return the offline page\r\n            if (event.request.headers.get('accept').includes('text/html')) {\r\n              return caches.match('/index.html');\r\n            }\r\n            throw error;\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('Service Worker fetch error:', error);\r\n        // Return a basic offline response\r\n        return new Response('Offline', { status: 503, statusText: 'Service Unavailable' });\r\n      }\r\n    })()\r\n  );\r\n});"],"names":["STATIC_CACHE_NAME","API_CACHE_NAME","urlsToCache","event","cache","cacheNames","cacheName","isApiRequest","request","cachedResponse","response","responseToCache","error"],"mappings":"AACA,MAAMA,EAAoB,kBACpBC,EAAiB,eAGjBC,EAAc,CAClB,IACA,cACA,iBACA,eACA,qBACA,sBAEF,EAGA,KAAK,iBAAiB,UAAYC,GAAU,CAC1CA,EAAM,UACJ,QAAQ,IAAI,CAEV,OAAO,KAAKH,CAAiB,EAAE,KAAMI,IACnC,QAAQ,IAAI,sBAAsB,EAC3BA,EAAM,OAAOF,CAAW,EAChC,EAED,OAAO,KAAKD,CAAc,CAChC,CAAK,CACL,EAEE,KAAK,YAAW,CAClB,CAAC,EAGD,KAAK,iBAAiB,WAAaE,GAAU,CAC3CA,EAAM,UACJ,OAAO,KAAI,EAAG,KAAME,GACX,QAAQ,IACbA,EAAW,IAAKC,GAAc,CAC5B,GAAIA,IAAcN,GAAqBM,IAAcL,EACnD,eAAQ,IAAI,sBAAuBK,CAAS,EACrC,OAAO,OAAOA,CAAS,CAE1C,CAAS,CACT,CACK,CACL,EAEEH,EAAM,UAAU,QAAQ,MAAO,CAAA,CACjC,CAAC,EAGD,MAAMI,EAAgBC,GACbA,EAAQ,IAAI,SAAS,oBAAoB,EAIlD,KAAK,iBAAiB,QAAUL,GAAU,CACxCA,EAAM,aACH,SAAY,CACX,GAAI,CACF,GAAII,EAAaJ,EAAM,OAAO,EAAG,CAG/B,MAAMM,EAAiB,MAAM,OAAO,MAAMN,EAAM,OAAO,EACvD,GAAIM,GAAkB,CAAC,UAAU,OAC/B,OAAOA,EAGT,GAAI,CAEF,MAAMC,EAAW,MAAM,MAAMP,EAAM,OAAO,EACpCQ,EAAkBD,EAAS,QAIjC,aADc,MAAM,OAAO,KAAKT,CAAc,GAClC,IAAIE,EAAM,QAASQ,CAAe,EAEvCD,CACR,MAAe,CAEd,MAAMD,EAAiB,MAAM,OAAO,MAAMN,EAAM,OAAO,EACvD,OAAIM,GAIG,IAAI,SACT,KAAK,UAAU,CAAE,MAAO,qDAAqD,CAAE,EAC/E,CACE,OAAQ,IACR,QAAS,CAAE,eAAgB,kBAAoB,CAChD,CACf,CACW,CACX,KAAe,CAEL,MAAMA,EAAiB,MAAM,OAAO,MAAMN,EAAM,OAAO,EACvD,GAAIM,EACF,OAAOA,EAIT,GAAI,CACF,MAAMC,EAAW,MAAM,MAAMP,EAAM,OAAO,EAG1C,aADc,MAAM,OAAO,KAAKH,CAAiB,GACrC,IAAIG,EAAM,QAASO,EAAS,MAAK,CAAE,EACxCA,CACR,OAAQE,EAAO,CAEd,GAAIT,EAAM,QAAQ,QAAQ,IAAI,QAAQ,EAAE,SAAS,WAAW,EAC1D,OAAO,OAAO,MAAM,aAAa,EAEnC,MAAMS,CACP,CACF,CACF,OAAQA,EAAO,CACd,eAAQ,MAAM,8BAA+BA,CAAK,EAE3C,IAAI,SAAS,UAAW,CAAE,OAAQ,IAAK,WAAY,qBAAqB,CAAE,CAClF,CACP,GAAQ,CACR,CACA,CAAC"}